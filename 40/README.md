# [토비의 스프링 6 - 이해와 원리](https://www.inflearn.com/course/토비의-스프링6-이해와-원리/dashboard)

> [깃허브](https://github.com/tobyspringboot/hellospring)

- [x] 2024/07/28 ~ 2024/08/01

## 내용 정리

`@SpringJUnitConfig` = `@ContextConfiguration` + `@ExtendWith(SpringExtension.class)`

상속을 통한 확장은 특정 상황에서는 유용할 수 있으나... 한계

- 상속포인트(추상 메서드)가 추가될 경우 자식이 모두 구현해야 함
- 구현해야하는 메소드 개수만큼 다양한 조합이 생길 수 있음
- 상위 클래스와 하위 클래스의 강한 결합

Seprated Interface 패턴: 인퍼테이스는 이를 구현하는 쪽(하위)보다 사용하는 쪽(상위)에 있는 것이 자연스러울 수 있음

Assertions 에서 BigDecimal 는 isEqualTo 로 검증하면 위험

- 내부적으로 equals 로 비교하는데, BigDecimal 은 금액의 숫자뿐 아니라 유효자리수까지 따짐
- isEqualByComparingTo 사용. 내부적으로 compareTo 사용

핵심 로직을 도메인 객체 안으로 가져오기

- 생성자 이용, 팩토리 메서드 이용
- 오브젝트에 대해서만 테스트를 만들 수 있게 되고, 그렇게 되면 의존성들에 대한 고민 필요 X
- 생성에 필요한 것들을 팩토리 메서드의 인자로 넣을 수 있음

> 생성자를 직접 호출하는 것보다 팩토리 메서드를 만드는 것이 좋음.  
> 그 안에서 의미있는 처리를 하는 코드를 넣을 수 있고, 이름을 부여할 수도 있음. -> 생성자는 이름이 없다

리팩토링 하려면 -> 테스트를 만들자

예외를 캐치하는 이유 -> 복구하기 위함

> 복구할만한 설계가 없다면 무시 -> 제일 앞단까지 예외가 던져지도록

메서드명을 지을 때

- `parse...` : parse 라는 메커니즘을 사용한다는 기능적인 의미
- `extract...` : 그 안에 어떻게 동작하는지(parse, ...)보다 목적을 표현할 수 있는 이름 -> 더 좋아보임

콜백을 사용하면 콜백을 사용하는 쪽에 있는 변수들(private 으로 선언된 변수들.. 등)을 사용할 수 있다

콜백은 변하기 쉬움 -> 인터페이스 먼저 생성

템플릿은 잘 변하지 않음 -> 바로 클래스로 정의해도 괜찮음

예외는 예외적인 상황에서만 사용

> 예외적인 상황이 아니라 컨트롤 하기위한 기법으로 사용하는 것(try-catch)은 좋지 않음

예외가 발생하면?

- 예외 상황을 복구해서 정상적인 흐름으로 전환할 수 있는가?
  1. 재시도: 많은 경우 1~2번 정도의 재시도로 문제를 해결하고 정상 흐름으로 복구 시킬 수 있음
  2. 대안: 외부 API 사용 중 장애가 나면 우리 시스템도 아무일도 못하고 시스템의 장애로 만들어야 하는가?
     - ex) 강의의 프로젝트 환율 API 가 무료라 조금 무서움 -> 2개 이상의 환율 정보 서비스 준비해둘 수 있음
- 버그인가?
  1. 예외가 발생한 코드의 버그인가?: 우리 코드면 고치면 됨
  2. 클라이언트의 버그인가?: 클라이언트 쪽의 발못된 사용 -> 적절한 안내, 친절한 오류 메시지로 대응
- 제어할 수 없는 예외상황인가?

예외를 무시하는 코드

```java
try {
    ...
} catch (Exception e) {
}
```

> 예외가 예외답게 처리되려면 복구를 한다거나, 다시 던져야 함 -> 알 수 있도록

```java
try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}
```

> 예외를 출력하기만함 -> 결국 무시임

`LocalContainerEntityManagerFactoryBean` 타입 빈 -> `EntityManagerFactory` 빈

> FactoryBean 의로 끝나는 빈은 등록된 타입의 빈이 아니라 실제로 만들어지는 것은 해당 타입이 아닌 그 안에서 만들어 주는 것이 빈으로 등록됨.  
> 요즘은 잘 안씀 -> `@Bean` 메서드가 FactoryBean 같은 역할

JPA 트랜잭션, JDBC 트랜잭션 -> 데이터 액세스 기술마다 트랜잭션 적용이 다름

> JDBC 는 별도 설정이 없으면 오토커밋으로 사용됨.  
> JPA 는 트랜잭션을 설정해주어야 함.
