# Splearn

`org.springframework.boot:spring-boot-docker-compose`

- 실행시 docker-compose 실행
- 디비 정보 등 가져와서 설정 값에 넣어줌

## 내용 정리

```java
public static Member create(
            String email,
            String nickname,
            String password,
            PasswordEncoder passwordEncoder
    );
```

> 비슷한 타입이 계속 연이어 나오게 되면 호출하는 쪽에서 혼란을 줄 수 있다. 이후 순서가 변경되는 등의 상황에서 오류가 발생할 수 있다.  
> 빌더를 사용할 수 있으나, 빌더는 누락된 파라미터를 컴파일 타임으로 체크할 수 없다.  
> 파라미터 개수가 너무 길 때, 파라미터 오브젝트를 사용할 수 있다. 생성자를 사용하면 또 위와 같은 문제가 발생할 수 있는 것이므로 생성자를 지우고 아래 메서드에서 모두 해결한다.

회원의 정보를 바깥에서 사용하고 이를 통해 로직을 구현하게 됨. 예) 회원이 ACTIVE 이면, ~~ 한다 와 같이.  
-> `isActive()` 와 같은 메서드를 만드는 것이 더 의미있을 수 있음.
`getStatus()` 응집도가 낮아질 수 있음. 값을 꺼내는 것으로 게터들이 있지만 상태를 꺼내오는 것은 로직을 적용하기 위한 경우가 많음.

> isDeactivated() 와 같은 것도 다 만들어야 할까? 이는 개발하면서 필요에 따라 추가하는 것이 좋다.

테스트에서는 var 를 많이 사용하기도 함. 코드를 간결하게 하여 다른 중요한 것들에 더 시선이 갈 수 있도록

2가지 이상 검증할 경우 원래는 2개의 테스트로 보고 쪼개는 것이 맞긴함. 하지만 간단한 것은 한 개에 넣기도함.

이메일 검증이 필요 -> 이 로직은 다양한 곳에서 사용될 수 있다.
응집도를 높이기 위해서 이메일을 클래스로 옮길 수 있다.

만들어진 회원을 같이 반환한다.  
엔티티를 반환하는 것이 안좋다고 생각할 수 있으나, 여기서는 완화된 계층을 따르기 때문에 꼭 dto 를 사용하지 않아도 괜찮다.

포트에는 주석으로 설명을 달아주는 것이 좋다.

jpa 3.2 에서는 record 에 @Embeddable을 사용할 수 없다. -> 기본 생성자 없음. 하이버네이트 6.2 에서는 지원. JPA 3.2 에서는 지원.

Member 에 JPA 관련 어노테이션이 있다고 해서 기술에 종속적이라고 보기 어려움. 어노테이션만 가지고는 특정 기술에서만 사용할 수 있는 것은 아니므로.

애플리케이션 서비스는 서비스에서 사용하는 주요 작업들을 어떤 절차를 거쳐서 작업을 수행하는가 누구와 협력하는가가 코드에 잘 드러나야 함

서비스 하나에 로직이 다 들어가면 너무 커짐. 적절하게 분리를 해야하는데 provided 포트 인터페이스는 그 기준이 될 수 있다.

실제로 목과 스텁을 직접 구현하기는 어렵기 때문에 Mockito 를 사용한다.

테스트에서 매번 레포지토리를 구현(페이크, 목)하는 것 보다 스프링, 실제 데이터베이스(혹은 유사하게 동작하는 H2)와 연동하는 것이 더 좋다.

> 설정에 문제가 있는 것은 아닌지 등등을 검증할 수 있음

`TestConfiguration` 의 빈이 실제 빈보다 우선 된다.

스프링 컨테이너가 동작하는 방식으로 >>테스트를 만드는 것이 어플리케이션 테스트에서는 더 좋다. 실행 시간은 더 걸릴 수 있으나 적절한 최적화가 있음. 같은 컨텍스트를 사용하는 테스트는 컨텍스트를 재사용하는 등.

애플리케이션의 최상의 퍼블릭 메서드는 추상적으로 읽기 쉽게 표현되어있는 것이 좋다. 프라이빗 메서드로 리팩터링 하자.

표준 자바 어노테이션으로 검증할 수 없는 것

- 커스텀 검증 어노테이션
- 많이 사용되지 않는 다면, 생성자에서 검증할 수도 있음.

`MemberService.activate` 와 같이 분명히 정상적인 id 가 들어와야 하는 경우 optional 에서 단순히 예외를 던짐 -> 없는 경우를 버그로 보는 것

spring data 의 repository save 를 호출하면 Event Publication, Auditing 발생

조회 로직과 변경 로직의 구현을 같은 곳에 두려고 하지 않는 이유는 시간이 지나면서 의존하는 것들이 점차 달라짐

변경에 대한 작업을 하다보면 한번 쯤은 잠깐 멈추고 코드를 정리하고 다듬는 시간이 필요하다. 
스프링 코드를 보면 커밋 중 중간중간 Polishing 이라는 것이 등장한다.

`@Fallback` 빈을 찾다가 다른 빈이 없으면 사용한다. spring 6.2 에서 들어감

orm.xml 을 사용하면 엔티티에서 도메인과 관련없는 jpa 어노테이션을 제거할 수 있다.

jpa 엔티티는 equals, hashcode 를 생성할 때 jpa buddy 플러그인이 생성해주는 방식을 사용하는 것이 좋다.