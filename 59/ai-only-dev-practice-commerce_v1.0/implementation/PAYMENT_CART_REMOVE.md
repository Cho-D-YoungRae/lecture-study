### 결제 완료 후 장바구니 상품 삭제 구현 전략

결제 성공 시 해당 상품들을 장바구니에서 제거하는 로직을 구현하기 위한 세 가지 전략을 제안합니다.

---

#### 전략 1: Logic Layer 간의 직접 협력 (PaymentManager -> CartItemManager)
가이드라인의 "Logic Layer는 예외적으로 서로 참조가 가능하다"는 규칙을 활용하는 방식입니다.

- **구현 방식**: `PaymentManager.success` 함수 내에서 `CartItemManager`를 참조하여 결제된 상품 옵션들을 장바구니에서 삭제합니다.
- **장점**:
    - 구현이 가장 단순하고 직관적입니다.
    - `PaymentManager.success`의 기존 트랜잭션 내에서 실행되므로 데이터 일관성 보장이 쉽습니다.
- **단점**:
    - 결제(Payment) 개념이 장바구니(Cart) 개념에 직접적으로 의존하게 됩니다.
    - 결제 성공 로직이 점점 무거워질 수 있습니다.

#### 전략 2: Presentation Layer(Assembler)에서의 조합
`PaymentAssembler`를 통해 결제 서비스와 장바구니 서비스를 순차적으로 호출하는 방식입니다.

- **구현 방식**: `PaymentAssembler`에 `callbackForSuccess` 처리를 위한 함수를 추가하고, `paymentService.success()` 호출 후 `cartService.deleteCartItems()`를 호출합니다.
- **장점**:
    - 도메인 간의 물리적 결합도가 낮습니다.
    - 각 서비스는 자신의 역할에만 집중할 수 있습니다.
- **단점**:
    - 트랜잭션 범위가 분리될 수 있습니다 (결제는 성공했으나 장바구니 삭제 시 오류가 발생할 경우 처리가 모호함).
    - 모든 결제 성공 진입점(Controller 등)이 Assembler를 거치도록 강제해야 합니다.

#### 전략 3: Spring Application Event를 활용한 비동기/분리 처리
Spring의 이벤트 메커니즘을 사용하여 결제 성공 이벤트를 발행하고 이를 구독하여 처리하는 방식입니다.

- **구현 방식**: `PaymentManager`에서 결제 완료 후 `PaymentSuccessEvent`를 발행하고, `CartEventListener`에서 이를 수신하여 장바구니를 정리합니다.
- **장점**:
    - 결제와 장바구니 도메인 간의 결합도를 완벽하게 분리할 수 있습니다.
    - 추후 결제 성공 시 메일 발송, 알림톡 전송 등 추가 요구사항 발생 시 확장성이 매우 뛰어납니다.
- **단점**:
    - 프로젝트에 이벤트 처리 인프라(Listener 설정 등)가 추가되어야 하므로 복잡도가 약간 상승합니다.
    - 이벤트 처리 방식(동기/비동기)에 따라 트랜잭션 및 오류 처리 전략을 별도로 설계해야 합니다.

---

### 제안 및 의견
현재 프로젝트 규모와 가이드라인을 고려했을 때, **전략 1(Logic Layer 간 직접 협력)**이 가장 효율적이고 생산성이 높을 것으로 판단됩니다. 가이드라인에서 이미 Logic Layer 간의 참조를 허용하고 있고, 한 트랜잭션 내에서 확실하게 장바구니가 정리되는 것이 비즈니스적으로도 안전하기 때문입니다.

다만, 향후 결제 완료 후 수행해야 할 후속 작업이 많아질 것으로 예상된다면 **전략 3(Event 활용)**으로의 전환을 고려해 볼 수 있습니다.
